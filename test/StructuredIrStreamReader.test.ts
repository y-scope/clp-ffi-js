import {
    afterEach,
    beforeAll,
    beforeEach,
    describe,
    expect,
    it,
} from "vitest";

import {describeCommonTests} from "./commonStreamReaderTests.js";
import {
    DECODE_CHUNK_SIZE,
    FILTERED_CHUNK_SIZE,
    LOG_LEVEL_INFO,
    NUM_EVENTS_MATCHING_KQL_INFO,
    NUM_EVENTS_STRUCTURED_COCKROACHDB,
    NUM_EVENTS_STRUCTURED_COCKROACHDB_INFO,
} from "./constants.js";
import {
    assertNonNull,
    type ClpStreamReader,
    createModule,
    createReader,
    loadTestData,
    type MainModule,
    type ReaderOptions,
} from "./utils.js";


let module: MainModule;
let data: Uint8Array;

beforeAll(async () => {
    module = await createModule();
    data = await loadTestData("structured-cockroachdb.clp.zst");
});

describe("Structured IR Stream: structured-cockroachdb.clp.zst", () => {
    let reader: ClpStreamReader;

    beforeEach(() => {
        reader = createReader(module, data);
    });

    afterEach(() => {
        reader.delete();
    });

    describeCommonTests({
        expectedNumEvents: NUM_EVENTS_STRUCTURED_COCKROACHDB,
        expectedStreamType: "STRUCTURED",
        getModule: () => module,
        getReader: () => reader,
    });

    it("should return empty filter map for log level without extracted keys", () => {
        reader.deserializeStream();

        reader.filterLogEvents([LOG_LEVEL_INFO]);
        const infoMap = reader.getFilteredLogEventMap();

        assertNonNull(infoMap);
        expect(infoMap.length).toBe(0);
    });

    it("should filter log events with KQL query", () => {
        reader.deserializeStream();

        reader.filterLogEvents(null, "INFO");
        const kqlMap = reader.getFilteredLogEventMap();

        assertNonNull(kqlMap);
        expect(kqlMap.length).toBe(NUM_EVENTS_MATCHING_KQL_INFO);
    });

    it("should return no results for KQL + log level filter without extracted keys", () => {
        reader.deserializeStream();

        reader.filterLogEvents([
            LOG_LEVEL_INFO,
        ], "INFO");
        const combinedMap = reader.getFilteredLogEventMap();

        assertNonNull(combinedMap);
        expect(combinedMap.length).toBe(0);
    });
});

describe("Structured IR Stream with logLevelKey", () => {
    const readerOptions: ReaderOptions = {
        logLevelKey: {isAutoGenerated: true, parts: ["loglevel"]},
        timestampKey: null,
        utcOffsetKey: null,
    };

    let reader: ClpStreamReader;

    beforeEach(() => {
        reader = createReader(module, data, readerOptions);
    });

    afterEach(() => {
        reader.delete();
    });

    it("should extract log levels from events", () => {
        const numEvents = reader.deserializeStream();

        const events = reader.decodeRange(
            0,
            Math.min(DECODE_CHUNK_SIZE, numEvents),
            false
        );

        assertNonNull(events);
        const [firstEvent] = events;
        assertNonNull(firstEvent);

        expect(firstEvent.logLevel).not.toBe(0);
    });

    it("should filter INFO events with extracted log levels", () => {
        reader.deserializeStream();

        reader.filterLogEvents([LOG_LEVEL_INFO]);
        const infoMap = reader.getFilteredLogEventMap();

        assertNonNull(infoMap);
        expect(infoMap.length).toBe(NUM_EVENTS_STRUCTURED_COCKROACHDB_INFO);
    });

    it("should decode filtered events with useFilter=true", () => {
        reader.deserializeStream();

        reader.filterLogEvents([LOG_LEVEL_INFO]);
        const filteredMap = reader.getFilteredLogEventMap();
        assertNonNull(filteredMap);

        const filteredEvents = reader.decodeRange(
            0,
            Math.min(FILTERED_CHUNK_SIZE, filteredMap.length),
            true
        );

        assertNonNull(filteredEvents);
        expect(filteredEvents.length).toBeGreaterThan(0);
    });

    it("should combine KQL and log level filters with extracted keys", () => {
        reader.deserializeStream();

        reader.filterLogEvents([
            LOG_LEVEL_INFO,
        ], "INFO");
        const combinedMap = reader.getFilteredLogEventMap();

        assertNonNull(combinedMap);
        expect(combinedMap.length).toBe(NUM_EVENTS_MATCHING_KQL_INFO);
    });
});
